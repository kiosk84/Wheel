const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '.env') });

const express = require('express');
const cors = require('cors'); // Added cors
const { Telegraf } = require('telegraf');

// API routes (Imported from server.js)
const participantsRoute = require('./routes/participants');
const pendingRoute = require('./routes/pending'); // Note: This might conflict with the /pending route defined below
const winnersRoute = require('./routes/winners');
const prizepoolRoute = require('./routes/prizepool');
const spinRoute = require('./routes/spin');
const timerRoute = require('./routes/timer');
const db = require('./db'); // Import database module

// Initialize Express
const app = express();

// Middleware (Combined from server.js and functions/index.js)
// Log all incoming HTTP requests
app.use((req, res, next) => { console.log(`REQ ${req.method} ${req.url} from ${req.ip}`); next(); });
// CORS configuration
app.use(cors({
  origin: (origin, cb) => {
    if (!origin) return cb(null, true); // allow non-browser or postman
    // Ensure FRONTEND_URL is loaded from .env
    const raw = process.env.FRONTEND_URL || '*';
    const allowed = raw.split(',').map(s => s.trim());
    if (allowed.includes('*') || allowed.includes(origin)) cb(null, true);
    else cb(new Error(`CORS blocked: ${origin}`));
  }
}));
app.use(express.json()); // Replaced bodyParser.json()

// Removed in-memory storage for pending/participants
// const pending = new Map();
// const participantsList = new Set();

// Bot setup (Kept from original functions/index.js)
const BOT_TOKEN = process.env.BOT_TOKEN;
if (!BOT_TOKEN) {
  console.error("Error: BOT_TOKEN is not defined in .env");
  process.exit(1);
}
const ADMIN_ID = process.env.ADMIN_ID;
const HOST = process.env.HOST_URL; // Used for Web App URL in bot message

// Track next spin time for front-end (Kept from original functions/index.js)
let nextSpinTime = null;
function scheduleNextSpin() {
  const now = new Date();
  const next = new Date(now);
  next.setHours(20, 0, 0, 0); // 20:00:00 —Å–µ–≥–æ–¥–Ω—è
  if (now >= next) {
    next.setDate(next.getDate() + 1);
  }
  nextSpinTime = next;
  setTimeout(async () => {
    try {
      const runLottery = require('./services/lottery');
      await runLottery();
      console.log('–ê–≤—Ç–æ-—Ä–æ–∑—ã–≥—Ä—ã—à –∑–∞–≤–µ—Ä—à—ë–Ω!');
    } catch (e) {
      console.error('–û—à–∏–±–∫–∞ –∞–≤—Ç–æ-—Ä–æ–∑—ã–≥—Ä—ã—à–∞:', e);
    }
    scheduleNextSpin();
  }, next - now);
}
// Initialize next spin schedule
scheduleNextSpin();

const bot = new Telegraf(BOT_TOKEN);
const users = new Set();

// Handle /start
bot.start(async (ctx) => {
  try {
    const id = ctx.from.id.toString();
    users.add(id);
    const isAdmin = id === ADMIN_ID;
    if (isAdmin) {
      await ctx.reply('–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, –∞–¥–º–∏–Ω! üëë\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:', {
        reply_markup: {
          inline_keyboard: [
            [{ text: 'üë• –°–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤', callback_data: 'getParticipants' }, { text: 'üèÜ –ü–æ–±–µ–¥–∏—Ç–µ–ª–∏', callback_data: 'getWinners' }],
            [{ text: 'üí∞ –ü—Ä–∏–∑–æ–≤–æ–π —Ñ–æ–Ω–¥', callback_data: 'getPrizePool' }, { text: 'üîÑ –°–±—Ä–æ—Å', callback_data: 'reset' }],
            [{ text: '‚ûï –î–æ–±–∞–≤–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞', callback_data: 'addParticipant' }, { text: 'üóë –£–¥–∞–ª–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞', callback_data: 'deletePrompt' }],
            [{ text: 'üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞', callback_data: 'getStats' }, { text: '‚è∞ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–∞–π–º–µ—Ä', callback_data: 'timerPrompt' }],
            [{ text: 'üåê –û—Ç–∫—Ä—ã—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ', web_app: { url: process.env.FRONTEND_URL || 'https://wheel-woad.vercel.app/' } }]
          ]
        }
      });
    } else {
      await ctx.reply(`üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∏–≥—Ä—É ¬´–ö–æ–ª–µ—Å–æ –§–æ—Ä—Ç—É–Ω—ã¬ª!\n‚ú® –¢—ã –Ω–∞ —à–∞–≥ –±–ª–∏–∂–µ –∫ —Ç–æ–º—É, —á—Ç–æ–±—ã –∏—Å–ø—ã—Ç–∞—Ç—å —É–¥–∞—á—É –∏ —Å–æ—Ä–≤–∞—Ç—å –∫—É—à! üî•\n\nüéÅ –ö–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ 20:00 –º—ã —Ä–∞–∑—ã–≥—Ä—ã–≤–∞–µ–º –ø—Ä–∏–∑–æ–≤–æ–π —Ñ–æ–Ω–¥ —Å—Ä–µ–¥–∏ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –∏–≥—Ä—ã.\n‚úÖ –í—Å—ë —á–µ—Å—Ç–Ω–æ, –ø—Ä–æ–∑—Ä–∞—á–Ω–æ –∏ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏!\n\n‚è∞ –°–ª–µ–¥—É—é—â–∏–π —Ä–æ–∑—ã–≥—Ä—ã—à —É–∂–µ —Å–∫–æ—Ä–æ ‚Äî –Ω–µ —É–ø—É—Å—Ç–∏ —à–∞–Ω—Å —Å—Ç–∞—Ç—å –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–º! üçÄ`, {
        reply_markup: {
          inline_keyboard: [
            [
              { text: '‚û°Ô∏è –û—Ç–∫—Ä—ã—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ', web_app: { url: 'https://wheel-woad.vercel.app/' } }
            ]
          ]
        }
      });
    }
  } catch (err) {
    console.error('Error in /start:', err);
    await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
  }
});

// Handle admin approve/reject callbacks (Moved before API routes mounting)
bot.on('callback_query', async (ctx) => {
  const data = ctx.callbackQuery.data;
  console.log('Received callback query:', data); // Log received data

  // Handle pending approval/rejection based on name (format: approve_NAME or reject_NAME)
  if (data.startsWith('approve_') || data.startsWith('reject_')) {
    const parts = data.split('_');
    const action = parts[0];
    const name = parts.slice(1).join('_'); // Re-join name if it contained underscores

    try {
      // Find the user in the pending table by name
      db.get('SELECT telegramId FROM pending WHERE name = ?', [name], async (err, pendingUser) => {
        if (err) {
          console.error('DB error fetching pending user:', err);
          await ctx.answerCbQuery('–û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö');
          return;
        }
        if (!pendingUser) {
          console.warn(`Pending user not found for name: ${name}`);
          await ctx.answerCbQuery('–ó–∞—è–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞');
          return;
        }

        const telegramId = pendingUser.telegramId;

        if (action === 'approve') {
          // Move from pending to participants
          db.serialize(() => {
            db.run('BEGIN TRANSACTION');
            db.run('INSERT INTO participants (name, telegramId) VALUES (?, ?)', [name, telegramId], (insertErr) => {
              if (insertErr) {
                console.error('DB error inserting participant:', insertErr);
                db.run('ROLLBACK');
                ctx.answerCbQuery('–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–∞');
                return;
              }
              db.run('DELETE FROM pending WHERE name = ?', [name], (deleteErr) => {
                if (deleteErr) {
                  console.error('DB error deleting pending:', deleteErr);
                  db.run('ROLLBACK');
                  ctx.answerCbQuery('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∑–∞—è–≤–∫–∏');
                  return;
                }
                // Increment prize pool (assuming table prize_pool exists with id=1)
                db.run('UPDATE prize_pool SET amount = amount + 100 WHERE id = 1', (poolErr) => {
                   if (poolErr) console.error('Prize pool update error:', poolErr); // Log error but continue
                   db.run('COMMIT', async (commitErr) => {
                     if (commitErr) {
                        console.error('DB commit error:', commitErr);
                        ctx.answerCbQuery('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è');
                        return;
                     }
                     console.log(`User ${name} (${telegramId}) approved.`);

                     // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –∏ –ø—Ä–∏–∑–æ–≤–æ–π —Ñ–æ–Ω–¥
                     db.get('SELECT COUNT(*) as count FROM participants', async (countErr, countRow) => {
                       const participantsCount = countRow?.count || 1;
                       const winChance = (100 / participantsCount).toFixed(2);

                       db.get('SELECT amount FROM prize_pool WHERE id = 1', async (prizeErr, prizeRow) => {
                         const prizePool = prizeRow?.amount || 100;

                         // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥—Ä–æ–±–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Å –∫–Ω–æ–ø–∫–æ–π –æ—Ç–∫—Ä—ã—Ç–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
                         await bot.telegram.sendMessage(telegramId,
                           `‚úÖ –í–∞—à–µ —É—á–∞—Å—Ç–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ!\n\n` +
                           `üë§ –ò–º—è: ${name}\n` +
                           `üë• –í—Å–µ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤: ${participantsCount}\n` +
                           `üí∞ –¢–µ–∫—É—â–∏–π –ø—Ä–∏–∑–æ–≤–æ–π —Ñ–æ–Ω–¥: ${prizePool}‚ÇΩ\n` +
                           `üéØ –í–∞—à —à–∞–Ω—Å –Ω–∞ –ø–æ–±–µ–¥—É: ${winChance}%\n\n` +
                           `‚è∞ –û–∂–∏–¥–∞–π—Ç–µ —Ä–æ–∑—ã–≥—Ä—ã—à! –£–¥–∞—á–∏! üçÄ`,
                           {
                             reply_markup: {
                               inline_keyboard: [
                                 [{ text: 'üéÆ –û—Ç–∫—Ä—ã—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ', web_app: { url: process.env.FRONTEND_URL || 'https://wheel-woad.vercel.app/' } }]
                               ]
                             }
                           }
                         );

                         // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –∞–¥–º–∏–Ω–∞
                         await ctx.editMessageText(
                           `‚úÖ –£—á–∞—Å—Ç–Ω–∏–∫ ${name} –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω.\n\n` +
                           `üë• –í—Å–µ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤: ${participantsCount}\n` +
                           `üí∞ –ü—Ä–∏–∑–æ–≤–æ–π —Ñ–æ–Ω–¥: ${prizePool}‚ÇΩ`
                         );

                         await ctx.answerCbQuery('–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ');
                       });
                     });
                   });
                });
              });
            });
          });
        } else if (action === 'reject') {
          // Just remove from pending
          db.run('DELETE FROM pending WHERE name = ?', [name], async (deleteErr) => {
            if (deleteErr) {
              console.error('DB error deleting pending:', deleteErr);
              await ctx.answerCbQuery('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∑–∞—è–≤–∫–∏');
              return;
            }
            console.log(`User ${name} (${telegramId}) rejected.`);

            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥—Ä–æ–±–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Å –∫–æ–Ω—Ç–∞–∫—Ç–∞–º–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –∏ –∫–Ω–æ–ø–∫–æ–π
            await bot.telegram.sendMessage(telegramId,
              `‚ùå –í–∞—à–∞ –∑–∞—è–≤–∫–∞ –Ω–∞ —É—á–∞—Å—Ç–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞.\n\n` +
              `–í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:\n` +
              `‚Ä¢ –ù–µ –Ω–∞–π–¥–µ–Ω –ø–ª–∞—Ç–µ–∂\n` +
              `‚Ä¢ –ù–µ–≤–µ—Ä–Ω–∞—è —Å—É–º–º–∞ –ø–ª–∞—Ç–µ–∂–∞\n` +
              `‚Ä¢ –î—Ä—É–≥–∞—è –ø—Ä–æ–±–ª–µ–º–∞ —Å –ø–ª–∞—Ç–µ–∂–æ–º\n\n` +
              `–î–ª—è —É—Ç–æ—á–Ω–µ–Ω–∏—è –¥–µ—Ç–∞–ª–µ–π –∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–¥–∞—á–∏ –∑–∞—è–≤–∫–∏, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π:\n` +
              `üì± Telegram: @support_contact\n` +
              `üìß Email: support@example.com`,
              {
                reply_markup: {
                  inline_keyboard: [
                    [{ text: 'üîÑ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞', web_app: { url: process.env.FRONTEND_URL || 'https://wheel-woad.vercel.app/' } }]
                  ]
                }
              }
            );

            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –∞–¥–º–∏–Ω–∞
            await ctx.editMessageText(`‚ùå –ó–∞—è–≤–∫–∞ —É—á–∞—Å—Ç–Ω–∏–∫–∞ ${name} –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞.`);
            await ctx.answerCbQuery('–û—Ç–∫–ª–æ–Ω–µ–Ω–æ');
          });
        }
      });
    } catch (error) {
      console.error('Error processing callback query:', error);
      await ctx.answerCbQuery('–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞');
    }
  } else if (data === 'getParticipants') {
    // –í—ã–≤–æ–¥ —Å–ø–∏—Å–∫–∞ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
    db.all('SELECT name FROM participants', async (err, rows) => {
      if (err) return ctx.reply('–û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö');
      if (!rows.length) return ctx.reply('–ù–µ—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤');
      const list = rows.map((r, i) => `${i + 1}. ${r.name}`).join('\n');
      await ctx.reply(`–°–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤:\n${list}`);
    });
  } else if (data === 'getWinners') {
    // –í—ã–≤–æ–¥ –∏—Å—Ç–æ—Ä–∏–∏ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π
    db.all('SELECT name, prize, timestamp FROM winners ORDER BY timestamp DESC LIMIT 10', async (err, rows) => {
      if (err) return ctx.reply('–û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö');
      if (!rows.length) return ctx.reply('–ü–æ–±–µ–¥–∏—Ç–µ–ª–µ–π –ø–æ–∫–∞ –Ω–µ—Ç');
      const list = rows.map(r => `${r.name} ‚Äî ${r.prize}‚ÇΩ (${new Date(r.timestamp).toLocaleString('ru-RU')})`).join('\n');
      await ctx.reply(`–ü–æ—Å–ª–µ–¥–Ω–∏–µ –ø–æ–±–µ–¥–∏—Ç–µ–ª–∏:\n${list}`);
    });
  } else if (data === 'getPrizePool') {
    // –í—ã–≤–æ–¥ –ø—Ä–∏–∑–æ–≤–æ–≥–æ —Ñ–æ–Ω–¥–∞
    db.get('SELECT amount FROM prize_pool WHERE id = 1', async (err, row) => {
      if (err) return ctx.reply('–û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö');
      await ctx.reply(`–¢–µ–∫—É—â–∏–π –ø—Ä–∏–∑–æ–≤–æ–π —Ñ–æ–Ω–¥: ${row?.amount || 0}‚ÇΩ`);
    });
  } else if (data === 'reset') {
    // –°–±—Ä–æ—Å —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –∏ –ø—Ä–∏–∑–æ–≤–æ–≥–æ —Ñ–æ–Ω–¥–∞
    db.serialize(() => {
      db.run('DELETE FROM participants');
      db.run('DELETE FROM pending');
      db.run('UPDATE prize_pool SET amount = 0 WHERE id = 1');
    });
    await ctx.reply('–í—Å–µ —É—á–∞—Å—Ç–Ω–∏–∫–∏ –∏ –ø—Ä–∏–∑–æ–≤–æ–π —Ñ–æ–Ω–¥ —Å–±—Ä–æ—à–µ–Ω—ã!');
  } else if (data === 'timerPrompt') {
    // –ó–∞–ø—Ä–æ—Å–∏—Ç—å/–ø–æ–∫–∞–∑–∞—Ç—å —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è —Ä–æ–∑—ã–≥—Ä—ã—à–∞ (–∑–∞–≥–ª—É—à–∫–∞)
    await ctx.reply('–í–≤–µ–¥–∏—Ç–µ –≤—Ä–µ–º—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —Ä–æ–∑—ã–≥—Ä—ã—à–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú (–Ω–∞–ø—Ä–∏–º–µ—Ä 20:00):');
    ctx.session.waitingForTimer = true;
  } else if (data === 'deletePrompt') {
    // –ó–∞–ø—Ä–æ—Å–∏—Ç—å –∏–º—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–∞
    await ctx.reply('–í–≤–µ–¥–∏—Ç–µ –∏–º—è —É—á–∞—Å—Ç–Ω–∏–∫–∞, –∫–æ—Ç–æ—Ä–æ–≥–æ –Ω—É–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å, –∫–æ–º–∞–Ω–¥–æ–π: /delete –ò–º—è');
  } else if (data === 'addParticipant') {
    // –ó–∞–ø—Ä–æ—Å–∏—Ç—å –∏–º—è –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–∞
    await ctx.reply('–í–≤–µ–¥–∏—Ç–µ –∏–º—è –Ω–æ–≤–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞ –∫–æ–º–∞–Ω–¥–æ–π: /add –ò–º—è');
  } else if (data === 'getStats') {
    // –ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
    db.serialize(() => {
      db.get('SELECT COUNT(*) as count FROM participants', async (err, participantsRow) => {
        if (err) return ctx.reply('–û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö');

        db.get('SELECT COUNT(*) as count FROM pending', async (err, pendingRow) => {
          if (err) return ctx.reply('–û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö');

          db.get('SELECT amount FROM prize_pool WHERE id = 1', async (err, prizeRow) => {
            if (err) return ctx.reply('–û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö');

            const stats = `üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n\n` +
                          `üë• –£—á–∞—Å—Ç–Ω–∏–∫–æ–≤: ${participantsRow?.count || 0}\n` +
                          `‚è≥ –û–∂–∏–¥–∞—é—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è: ${pendingRow?.count || 0}\n` +
                          `üí∞ –ü—Ä–∏–∑–æ–≤–æ–π —Ñ–æ–Ω–¥: ${prizeRow?.amount || 0}‚ÇΩ\n` +
                          `‚è∞ –°–ª–µ–¥—É—é—â–∏–π —Ä–æ–∑—ã–≥—Ä—ã—à: ${nextSpinTime ? nextSpinTime.toLocaleTimeString('ru-RU') : '–ù–µ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω'}`;

            await ctx.reply(stats);
          });
        });
      });
    });
  } else {
    // Handle other callback queries if necessary
    console.log(`Unhandled callback query data: ${data}`);
    // Consider calling next() if using middleware pattern or just answering
    await ctx.answerCbQuery(); // Acknowledge other callbacks silently
  }
});

// Handle /delete command
bot.command('delete', async (ctx) => {
  const id = ctx.from.id.toString();
  if (id !== ADMIN_ID) return ctx.reply('–¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω –º–æ–∂–µ—Ç —É–¥–∞–ª—è—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.');
  const args = ctx.message.text.split(' ').slice(1);
  if (!args.length) return ctx.reply('–£–∫–∞–∂–∏—Ç–µ –∏–º—è —É—á–∞—Å—Ç–Ω–∏–∫–∞: /delete –ò–º—è');
  const name = args.join(' ');
  db.get('SELECT * FROM participants WHERE name = ?', [name], (err, row) => {
    if (err) return ctx.reply('–û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö');
    if (!row) return ctx.reply('–£—á–∞—Å—Ç–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω');
    db.run('DELETE FROM participants WHERE name = ?', [name], (err2) => {
      if (err2) return ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏');
      ctx.reply(`–£—á–∞—Å—Ç–Ω–∏–∫ ${name} —É–¥–∞–ª—ë–Ω.`);
    });
  });
});

// Handle /add command - –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —É—á–∞—Å—Ç–Ω–∏–∫–∞ –∞–¥–º–∏–Ω–æ–º
bot.command('add', async (ctx) => {
  const id = ctx.from.id.toString();
  if (id !== ADMIN_ID) return ctx.reply('–¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω –º–æ–∂–µ—Ç –¥–æ–±–∞–≤–ª—è—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.');
  const args = ctx.message.text.split(' ').slice(1);
  if (!args.length) return ctx.reply('–£–∫–∞–∂–∏—Ç–µ –∏–º—è —É—á–∞—Å—Ç–Ω–∏–∫–∞: /add –ò–º—è');
  const name = args.join(' ');

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ —É—á–∞—Å—Ç–Ω–∏–∫ —Å —Ç–∞–∫–∏–º –∏–º–µ–Ω–µ–º
  db.get('SELECT 1 FROM participants WHERE name = ?', [name], (err, row) => {
    if (err) return ctx.reply('–û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö');
    if (row) return ctx.reply('–£—á–∞—Å—Ç–Ω–∏–∫ —Å —Ç–∞–∫–∏–º –∏–º–µ–Ω–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç');

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π telegramId –¥–ª—è —É—á–∞—Å—Ç–Ω–∏–∫–∞, –¥–æ–±–∞–≤–ª–µ–Ω–Ω–æ–≥–æ –∞–¥–º–∏–Ω–æ–º
    const adminAddedId = `admin_added_${Date.now()}`;

    // –î–æ–±–∞–≤–ª—è–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞
    db.run('INSERT INTO participants (name, telegramId) VALUES (?, ?)', [name, adminAddedId], (err2) => {
      if (err2) return ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —É—á–∞—Å—Ç–Ω–∏–∫–∞');

      // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ø—Ä–∏–∑–æ–≤–æ–π —Ñ–æ–Ω–¥
      db.run('UPDATE prize_pool SET amount = amount + 100 WHERE id = 1', (err3) => {
        if (err3) {
          console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–∏–∑–æ–≤–æ–≥–æ —Ñ–æ–Ω–¥–∞:', err3);
          return ctx.reply('–£—á–∞—Å—Ç–Ω–∏–∫ –¥–æ–±–∞–≤–ª–µ–Ω, –Ω–æ –≤–æ–∑–Ω–∏–∫–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø—Ä–∏–∑–æ–≤–æ–≥–æ —Ñ–æ–Ω–¥–∞');
        }

        ctx.reply(`‚úÖ –£—á–∞—Å—Ç–Ω–∏–∫ ${name} —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω!\nüí∞ –ü—Ä–∏–∑–æ–≤–æ–π —Ñ–æ–Ω–¥ —É–≤–µ–ª–∏—á–µ–Ω –Ω–∞ 100‚ÇΩ`);
      });
    });
  });
});

// --- API Endpoints ---

// Mount API endpoints from routes/ (Copied from server.js)
app.use('/participants', participantsRoute);
app.use('/pending', pendingRoute); // Uncommented: Use routes from pending.js
app.use('/winners', winnersRoute);
app.use('/prizepool', prizepoolRoute);
app.use('/spin', spinRoute);
app.use('/timer', timerRoute);

// API routes defined directly in this file (Kept from original functions/index.js)
// Frontend notification API
app.post('/notify', async (req, res) => {
  const { telegramId, message } = req.body;
  if (!telegramId || !message) return res.status(400).json({ error: 'Missing telegramId or message' });
  try {
    await bot.telegram.sendMessage(telegramId, message);
    res.json({ status: 'ok' });
  } catch (err) {
    console.error('Error sending message:', err);
    res.status(500).json({ error: 'Failed to send message' });
  }
});

// Removed direct definitions for POST /pending and GET /pending/check
// These are now handled by functions/routes/pending.js

// --- Bot Launch and Server Start ---

// Launch bot (Kept from original functions/index.js)
// Make sure bot is launched *after* routes and handlers are defined
bot.launch({ polling: true }) // Using polling as in original functions/index.js
  .then(() => console.log('Bot launched successfully (polling)'))
  .catch(err => console.error('Bot launch error:', err));

// Graceful shutdown (Kept from original functions/index.js)
process.once('SIGINT', () => { console.log("SIGINT received, stopping bot..."); bot.stop('SIGINT'); process.exit(0); });
process.once('SIGTERM', () => { console.log("SIGTERM received, stopping bot..."); bot.stop('SIGTERM'); process.exit(0); });


// Start Express server (Using port from server.js logic)
const PORT = process.env.PORT || 8080;
app.listen(PORT, '0.0.0.0', () => {
  console.log(`Express server running at http://0.0.0.0:${PORT}`);
  // Optional: Set webhook if HOST_URL and WEBHOOK_PATH are defined (alternative to polling)
  // const webhookPath = process.env.WEBHOOK_PATH;
  // if (HOST && webhookPath) {
  //   const webhookUrl = `${HOST}${webhookPath}`;
  //   bot.telegram.setWebhook(webhookUrl)
  //     .then(() => console.log(`Webhook set to ${webhookUrl}`))
  //     .catch(err => console.error('Error setting webhook:', err));
  //   // Need to handle webhook updates on a specific route, e.g., app.use(bot.webhookCallback(webhookPath));
  // } else {
  //   console.log("Polling mode enabled. HOST_URL or WEBHOOK_PATH not fully configured for webhook mode.");
  // }
});

// Export bot and app for potential use in routes or other modules
module.exports = { app, bot, ADMIN_ID };
